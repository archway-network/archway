// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: archway/cwica/v1/sudo.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/ibc-go/v8/modules/core/04-channel/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Sudopayload is the payload for the sudo call sent by the cwica module on IBC
// actions
type SudoPayload struct {
	// ICA is the message which carries the success responses
	Ica *ICASuccess `protobuf:"bytes,1,opt,name=ica,proto3" json:"ica,omitempty"`
}

func (m *SudoPayload) Reset()         { *m = SudoPayload{} }
func (m *SudoPayload) String() string { return proto.CompactTextString(m) }
func (*SudoPayload) ProtoMessage()    {}
func (*SudoPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_875a60870b33cbab, []int{0}
}
func (m *SudoPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SudoPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SudoPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SudoPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SudoPayload.Merge(m, src)
}
func (m *SudoPayload) XXX_Size() int {
	return m.Size()
}
func (m *SudoPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SudoPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SudoPayload proto.InternalMessageInfo

func (m *SudoPayload) GetIca() *ICASuccess {
	if m != nil {
		return m.Ica
	}
	return nil
}

// ICASuccess is the success message after the ICA operation has taken place
type ICASuccess struct {
	// account_registered is the message which carries the success response after
	// the ica account has been registered
	AccountRegistered *AccountRegistered `protobuf:"bytes,1,opt,name=account_registered,json=accountRegistered,proto3" json:"account_registered,omitempty"`
	// tx_executed is the message which carries the success response after the ica
	// tx has been executed
	TxExecuted *TxExecuted `protobuf:"bytes,2,opt,name=tx_executed,json=txExecuted,proto3" json:"tx_executed,omitempty"`
}

func (m *ICASuccess) Reset()         { *m = ICASuccess{} }
func (m *ICASuccess) String() string { return proto.CompactTextString(m) }
func (*ICASuccess) ProtoMessage()    {}
func (*ICASuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_875a60870b33cbab, []int{1}
}
func (m *ICASuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ICASuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ICASuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ICASuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICASuccess.Merge(m, src)
}
func (m *ICASuccess) XXX_Size() int {
	return m.Size()
}
func (m *ICASuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_ICASuccess.DiscardUnknown(m)
}

var xxx_messageInfo_ICASuccess proto.InternalMessageInfo

func (m *ICASuccess) GetAccountRegistered() *AccountRegistered {
	if m != nil {
		return m.AccountRegistered
	}
	return nil
}

func (m *ICASuccess) GetTxExecuted() *TxExecuted {
	if m != nil {
		return m.TxExecuted
	}
	return nil
}

// AccountRegistered is contains the address of the registered account on the
// counterparty chain
type AccountRegistered struct {
	// counterparty_address is the address of the account on the counterparty
	// chain
	CounterpartyAddress string `protobuf:"bytes,1,opt,name=counterparty_address,json=counterpartyAddress,proto3" json:"counterparty_address,omitempty"`
}

func (m *AccountRegistered) Reset()         { *m = AccountRegistered{} }
func (m *AccountRegistered) String() string { return proto.CompactTextString(m) }
func (*AccountRegistered) ProtoMessage()    {}
func (*AccountRegistered) Descriptor() ([]byte, []int) {
	return fileDescriptor_875a60870b33cbab, []int{2}
}
func (m *AccountRegistered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRegistered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRegistered.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRegistered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRegistered.Merge(m, src)
}
func (m *AccountRegistered) XXX_Size() int {
	return m.Size()
}
func (m *AccountRegistered) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRegistered.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRegistered proto.InternalMessageInfo

func (m *AccountRegistered) GetCounterpartyAddress() string {
	if m != nil {
		return m.CounterpartyAddress
	}
	return ""
}

// TxExecuted is the response message after the execute of the ICA tx
type TxExecuted struct {
	// packet is the ibc packet which was executed
	Packet *types.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet,omitempty"`
	// data is the response data after the tx has been executed
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TxExecuted) Reset()         { *m = TxExecuted{} }
func (m *TxExecuted) String() string { return proto.CompactTextString(m) }
func (*TxExecuted) ProtoMessage()    {}
func (*TxExecuted) Descriptor() ([]byte, []int) {
	return fileDescriptor_875a60870b33cbab, []int{3}
}
func (m *TxExecuted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxExecuted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxExecuted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxExecuted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxExecuted.Merge(m, src)
}
func (m *TxExecuted) XXX_Size() int {
	return m.Size()
}
func (m *TxExecuted) XXX_DiscardUnknown() {
	xxx_messageInfo_TxExecuted.DiscardUnknown(m)
}

var xxx_messageInfo_TxExecuted proto.InternalMessageInfo

func (m *TxExecuted) GetPacket() *types.Packet {
	if m != nil {
		return m.Packet
	}
	return nil
}

func (m *TxExecuted) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*SudoPayload)(nil), "archway.cwica.v1.SudoPayload")
	proto.RegisterType((*ICASuccess)(nil), "archway.cwica.v1.ICASuccess")
	proto.RegisterType((*AccountRegistered)(nil), "archway.cwica.v1.AccountRegistered")
	proto.RegisterType((*TxExecuted)(nil), "archway.cwica.v1.TxExecuted")
}

func init() { proto.RegisterFile("archway/cwica/v1/sudo.proto", fileDescriptor_875a60870b33cbab) }

var fileDescriptor_875a60870b33cbab = []byte{
	// 363 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xb1, 0x4e, 0xeb, 0x30,
	0x14, 0x86, 0x9b, 0x7b, 0xaf, 0x2a, 0x5d, 0xf7, 0x0e, 0xb7, 0xa6, 0x43, 0xd5, 0xa2, 0x08, 0xc2,
	0xc2, 0x82, 0x4d, 0xe8, 0xdc, 0xa1, 0x20, 0x90, 0x60, 0xaa, 0x5c, 0x58, 0x58, 0x2a, 0xc7, 0xb6,
	0xd2, 0xa8, 0x25, 0x8e, 0x1c, 0xa7, 0x4d, 0xde, 0x82, 0x37, 0xe0, 0x75, 0x18, 0x3b, 0x32, 0xa2,
	0xf6, 0x45, 0x50, 0x1c, 0xb7, 0x45, 0xad, 0xd8, 0xfe, 0x9c, 0xff, 0xd3, 0x39, 0xe7, 0x3f, 0x31,
	0xe8, 0x52, 0xc5, 0x26, 0x0b, 0x5a, 0x60, 0xb6, 0x88, 0x18, 0xc5, 0x73, 0x1f, 0xa7, 0x19, 0x97,
	0x28, 0x51, 0x52, 0x4b, 0xf8, 0xdf, 0x9a, 0xc8, 0x98, 0x68, 0xee, 0x77, 0x5a, 0xa1, 0x0c, 0xa5,
	0x31, 0x71, 0xa9, 0x2a, 0xae, 0x73, 0x1a, 0x05, 0x0c, 0x33, 0xa9, 0x04, 0x66, 0x13, 0x1a, 0xc7,
	0x62, 0x56, 0xf6, 0xb1, 0xb2, 0x42, 0xbc, 0x3e, 0x68, 0x8c, 0x32, 0x2e, 0x87, 0xb4, 0x98, 0x49,
	0xca, 0x21, 0x02, 0xbf, 0x23, 0x46, 0xdb, 0xce, 0x89, 0x73, 0xde, 0xb8, 0x3a, 0x46, 0xfb, 0x73,
	0xd0, 0xfd, 0xcd, 0x60, 0x94, 0x31, 0x26, 0xd2, 0x94, 0x94, 0xa0, 0xf7, 0xe6, 0x00, 0xb0, 0xab,
	0x41, 0x02, 0x20, 0x65, 0x4c, 0x66, 0xb1, 0x1e, 0x2b, 0x11, 0x46, 0xa9, 0x16, 0x4a, 0x70, 0xdb,
	0xed, 0xec, 0xb0, 0xdb, 0xa0, 0x62, 0xc9, 0x16, 0x25, 0x4d, 0xba, 0x5f, 0x82, 0x7d, 0xd0, 0xd0,
	0xf9, 0x58, 0xe4, 0x82, 0x65, 0x5a, 0xf0, 0xf6, 0xaf, 0x9f, 0x56, 0x7b, 0xcc, 0x6f, 0x2d, 0x43,
	0x80, 0xde, 0x6a, 0xef, 0x0e, 0x34, 0x0f, 0xc6, 0x40, 0x1f, 0xb4, 0x4c, 0x49, 0xa8, 0x84, 0x2a,
	0x5d, 0x8c, 0x29, 0xe7, 0x4a, 0xa4, 0xa9, 0xd9, 0xf4, 0x2f, 0x39, 0xfa, 0xee, 0x0d, 0x2a, 0xcb,
	0x7b, 0x02, 0x60, 0x37, 0x01, 0xf6, 0x40, 0x3d, 0xa1, 0x6c, 0x2a, 0xb4, 0x0d, 0xd7, 0x45, 0x51,
	0xc0, 0x50, 0x79, 0x6a, 0xb4, 0xb9, 0xef, 0xdc, 0x47, 0x43, 0x83, 0x10, 0x8b, 0x42, 0x08, 0xfe,
	0x70, 0xaa, 0xa9, 0x89, 0xf0, 0x8f, 0x18, 0x7d, 0xfd, 0xf0, 0xbe, 0x72, 0x9d, 0xe5, 0xca, 0x75,
	0x3e, 0x57, 0xae, 0xf3, 0xba, 0x76, 0x6b, 0xcb, 0xb5, 0x5b, 0xfb, 0x58, 0xbb, 0xb5, 0xe7, 0xcb,
	0x30, 0xd2, 0x93, 0x2c, 0x40, 0x4c, 0xbe, 0x60, 0x1b, 0xf6, 0x22, 0x16, 0x7a, 0x21, 0xd5, 0x74,
	0xf3, 0x8d, 0x73, 0xfb, 0x3c, 0x74, 0x91, 0x88, 0x34, 0xa8, 0x9b, 0x5f, 0xda, 0xfb, 0x0a, 0x00,
	0x00, 0xff, 0xff, 0x43, 0xeb, 0x0e, 0xa1, 0x3c, 0x02, 0x00, 0x00,
}

func (m *SudoPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SudoPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SudoPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ica != nil {
		{
			size, err := m.Ica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSudo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ICASuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICASuccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ICASuccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxExecuted != nil {
		{
			size, err := m.TxExecuted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSudo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AccountRegistered != nil {
		{
			size, err := m.AccountRegistered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSudo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountRegistered) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRegistered) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRegistered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyAddress) > 0 {
		i -= len(m.CounterpartyAddress)
		copy(dAtA[i:], m.CounterpartyAddress)
		i = encodeVarintSudo(dAtA, i, uint64(len(m.CounterpartyAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxExecuted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxExecuted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxExecuted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSudo(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Packet != nil {
		{
			size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSudo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSudo(dAtA []byte, offset int, v uint64) int {
	offset -= sovSudo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SudoPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ica != nil {
		l = m.Ica.Size()
		n += 1 + l + sovSudo(uint64(l))
	}
	return n
}

func (m *ICASuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRegistered != nil {
		l = m.AccountRegistered.Size()
		n += 1 + l + sovSudo(uint64(l))
	}
	if m.TxExecuted != nil {
		l = m.TxExecuted.Size()
		n += 1 + l + sovSudo(uint64(l))
	}
	return n
}

func (m *AccountRegistered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CounterpartyAddress)
	if l > 0 {
		n += 1 + l + sovSudo(uint64(l))
	}
	return n
}

func (m *TxExecuted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Packet != nil {
		l = m.Packet.Size()
		n += 1 + l + sovSudo(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSudo(uint64(l))
	}
	return n
}

func sovSudo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSudo(x uint64) (n int) {
	return sovSudo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SudoPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSudo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SudoPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SudoPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ica == nil {
				m.Ica = &ICASuccess{}
			}
			if err := m.Ica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSudo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSudo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICASuccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSudo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICASuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICASuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRegistered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountRegistered == nil {
				m.AccountRegistered = &AccountRegistered{}
			}
			if err := m.AccountRegistered.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxExecuted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxExecuted == nil {
				m.TxExecuted = &TxExecuted{}
			}
			if err := m.TxExecuted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSudo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSudo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRegistered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSudo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRegistered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRegistered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSudo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSudo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxExecuted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSudo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxExecuted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxExecuted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Packet == nil {
				m.Packet = &types.Packet{}
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSudo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSudo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSudo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSudo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSudo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSudo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSudo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSudo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSudo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSudo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSudo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSudo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSudo = fmt.Errorf("proto: unexpected end of group")
)
